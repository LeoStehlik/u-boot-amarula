U-Boot for Freescale i.MX6

This file contains information for the port of U-Boot to the Freescale i.MX6
SoC.

1. CONVENTIONS FOR FUSE ASSIGNMENTS
-----------------------------------

1.1 MAC Address: It is stored in fuse bank 4, with the 32 lsbs in word 2 and the
    16 msbs in word 3[15:0].
    For i.MX6SX and i.MX6UL, they have two MAC addresses. The second MAC address
    is stored in fuse bank 4, with the 16 lsb in word 3[31:16] and the 32 msbs in 
    word 4.

Example:

For reading the MAC address fuses on a MX6Q:

- The MAC address is stored in two fuse addresses (the fuse addresses are
described in the Fusemap Descriptions table from the mx6q Reference Manual):

0x620[31:0] - MAC_ADDR[31:0]
0x630[15:0] - MAC_ADDR[47:32]

In order to use the fuse API, we need to pass the bank and word values, which
are calculated as below:

Fuse address for the lower MAC address: 0x620
Base address for the fuses: 0x400

(0x620 - 0x400)/0x10 = 0x22 = 34 decimal

As the fuses are arranged in banks of 8 words:

34 / 8 = 4 and the remainder is 2, so in this case:

bank = 4
word = 2

And the U-Boot command would be:

=> fuse read 4 2
Reading bank 4:

Word 0x00000002: 9f027772

Doing the same for the upper MAC address:

Fuse address for the upper MAC address: 0x630
Base address for the fuses: 0x400

(0x630 - 0x400)/0x10 = 0x23 = 35 decimal

As the fuses are arranged in banks of 8 words:

35 / 8 = 4 and the remainder is 3, so in this case:

bank = 4
word = 3

And the U-Boot command would be:

=> fuse read 4 3
Reading bank 4:

Word 0x00000003: 00000004

,which matches the ethaddr value:
=> echo ${ethaddr}
00:04:9f:02:77:72

Some other useful hints:

- The 'bank' and 'word' numbers can be easily obtained from the mx6 Reference
Manual. For the mx6quad case, please check the "46.5 OCOTP Memory Map/Register
Definition" from the "i.MX 6Dual/6Quad Applications Processor Reference Manual,
Rev. 1, 04/2013" document. For example, for the MAC fuses we have:

Address:
21B_C620	Value of OTP Bank4 Word2 (MAC Address)(OCOTP_MAC0)

21B_C630	Value of OTP Bank4 Word3 (MAC Address)(OCOTP_MAC1)

- The command '=> fuse read 4 2 2' reads the whole MAC addresses at once:

=> fuse read 4 2 2
Reading bank 4:

Word 0x00000002: 9f027772 00000004

2. Using imx_usb_loader for first install with SPL
--------------------------------------------------

imx_usb_loader is a very nice tool by Boundary Devices that
allow to install U-Boot without a JTAG debugger, using
the USB boot mode as described in the manual. It is
a replacement for Freescale's MFGTOOLS.

The sources can be found here:

	https://github.com/boundarydevices/imx_usb_loader.git

Booting in USB mode, the i.MX6 announces itself to the Linux Host as:

Bus 001 Device 111: ID 15a2:0061 Freescale Semiconductor, Inc.

imx_usb_loader is able to download a single file (u-boot.imx)
to the board. For boards without SPL support, it is enough to
issue the command:

	sudo ../imx_usb_loader/imx_usb -v u-boot.imx

In order to load SPL and u-boot.img via imx_usb_loader tool,
please refer to doc/README.sdp.

3. NAND Boot on i.MX6 with SPL support
--------------------------------------

Writing/updating boot image in nand device is not straight forward in
i.MX6 platform and it requires boot control block(BCB) to be configured.

BCB contains two data structures, Firmware Configuration Block(FCB) and
Discovered Bad Block Table(DBBT). FCB has nand timings, DBBT search area,
page address of primary and secondary firmware. See IMX6DQRM Section 8.5.2.2
for more information.

We can't use 'nand write' command to write SPL/firmware image directly
like other platforms does. So we need special setup to write BCB block
as per IMX6QDL reference manual 'nandbcb update' command do that job.

for nand boot, up on reset bootrom look for FCB structure in
first block's if FCB found the nand timings are loaded for
further reads. once FCB read done, DTTB will load and
finally primary or secondary firmware will load which is boot image.

cmd_nandbcb will create FCB these structures
by taking mtd partition as an example.
- initial code will erase entire partition
- followed by FCB setup, like first 4 block for FCB/DBBT write,
  rest is split into two for primary and secondary firmware
- write firmware at primary and secondary blocks(two times same image)
- finally write fcb/dttb in first 4 block.

Typical NAND BCB layout:
=======================

   no.of blocks = partition size / erasesize
   no.of fcb/dbbt blocks = 4
   no.of FW blocks = (no.of blocks - no.of fcb/dbbt blocks) / 2
   FW1 offset = no.of fcb/dbbt
   FW2 offset = FW1 offset + no.of FW blocks

block  0          1          2          3          4     FW2 offset
        ---------------------------------------------------------------
       |FCB/DBBT 0|FCB/DBBT 1|FCB/DBBT 2|FCB/DBBT 3|  FW 1  |  FW 2   |
       ----------------------------------------------------------------

On summary, nandbcb update will
- erase the entire partition
- create BCB by creating 4 FCB/BDDT block followed by
  2 FW blocks based on partition size and erasesize.
- fill FCB/DBBT structures
- write FW/SPL in FW0 and FW1(same image in two times)
- write FCB/DBBT in first 4 blocks

step-1: write SPL

icorem6qdl> fatload mmc 0:1 $loadaddr SPL
reading SPL
31744 bytes read in 15 ms (2 MiB/s)

icorem6qdl> nandbcb update $loadaddr spl $filesize
device 0 offset 0x0, size 0x7c00
Erasing at 0x1c0000 -- 100% complete.
NAND fw write: 0x100000 offset, 0x9000 bytes written: OK
NAND fw write: 0x180000 offset, 0x9000 bytes written: OK

step-2: write u-boot-dtb.img

icorem6qdl> nand erase.part uboot
NAND erase.part: device 0 offset 0x200000, size 0x200000
Erasing at 0x3c0000 -- 100% complete.
OK

icorem6qdl> fatload mmc 0:1 $loadaddr u-boot-dtb.img
reading u-boot-dtb.img
508967 bytes read in 48 ms (10.1 MiB/s)

icorem6qdl> nand write ${loadaddr} uboot ${filesize}
NAND write: device 0 offset 0x200000, size 0x7c427
508967 bytes written: OK
